{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     * See sections 4 and 5 of https://datatracker.ietf.org/doc/html/rfc4648\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    string internal constant _TABLE_URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE, true);\n    }\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64Url `string` representation.\n     * Output is not padded with `=` as specified in https://www.rfc-editor.org/rfc/rfc4648[rfc4648].\n     */\n    function encodeURL(bytes memory data) internal pure returns (string memory) {\n        return _encode(data, _TABLE_URL, false);\n    }\n\n    /**\n     * @dev Internal table-agnostic conversion\n     */\n    function _encode(bytes memory data, string memory table, bool withPadding) private pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // If padding is enabled, the final length should be `bytes` data length divided by 3 rounded up and then\n        // multiplied by 4 so that it leaves room for padding the last chunk\n        // - `data.length + 2`  -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // - `4 *`              -> 4 characters for each chunk\n        // This is equivalent to: 4 * Math.ceil(data.length / 3)\n        //\n        // If padding is disabled, the final length should be `bytes` data length multiplied by 4/3 rounded up as\n        // opposed to when padding is required to fill the last chunk.\n        // - `4 * data.length`  -> 4 characters for each chunk\n        // - ` + 2`             -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // This is equivalent to: Math.ceil((4 * data.length) / 3)\n        uint256 resultLength = withPadding ? 4 * ((data.length + 2) / 3) : (4 * data.length + 2) / 3;\n\n        string memory result = new string(resultLength);\n\n        assembly (\"memory-safe\") {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            if withPadding {\n                // When data `bytes` is not exactly 3 bytes long\n                // it is padded with `=` characters at the end\n                switch mod(mload(data), 3)\n                case 1 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                    mstore8(sub(resultPtr, 2), 0x3d)\n                }\n                case 2 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2²⁵⁶ + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 exp;\n        unchecked {\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\n            value >>= exp;\n            result += exp;\n\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\n            value >>= exp;\n            result += exp;\n\n            result += SafeCast.toUint(value > 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        uint256 isGt;\n        unchecked {\n            isGt = SafeCast.toUint(value > (1 << 128) - 1);\n            value >>= isGt * 128;\n            result += isGt * 16;\n\n            isGt = SafeCast.toUint(value > (1 << 64) - 1);\n            value >>= isGt * 64;\n            result += isGt * 8;\n\n            isGt = SafeCast.toUint(value > (1 << 32) - 1);\n            value >>= isGt * 32;\n            result += isGt * 4;\n\n            isGt = SafeCast.toUint(value > (1 << 16) - 1);\n            value >>= isGt * 16;\n            result += isGt * 2;\n\n            result += SafeCast.toUint(value > (1 << 8) - 1);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/originForge/sbtFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {modifiersFacet} from \"../shared/utils/modifiersFacet.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC721} from \"../shared/interfaces/IERC721.sol\";\nimport {svg} from \"../shared/libraries/svg.sol\";\nimport {Metadata, DisplayType} from \"../shared/libraries/Metadata.sol\";\nimport {json} from \"../shared/libraries/json.sol\";\nimport {Solarray} from \"../shared/libraries/Solarray.sol\";\nimport {LibString} from \"solady/src/utils/LibString.sol\";\n\ncontract sbtFacet is modifiersFacet {\n    using svg for *;\n    using Metadata for *;\n\n\n    // delegate EOA mint\n    function nft_mint(address _to, uint _tokenId) external {\n        // _mint(_to, _tokenId);\n    }\n\n    function nft_getUri(uint _tokenId) external view returns (string memory) {\n        string[] memory staticTraits = getAttributes(_tokenId);\n        string[] memory dynamicTraits = getDynamicAttributes(_tokenId);\n        string[] memory combined = new string[](staticTraits.length + dynamicTraits.length);\n\n\n        for(uint256 i = 0; i < staticTraits.length; i++){\n            combined[i] = staticTraits[i];\n        }\n        for(uint256 i = 0; i < dynamicTraits.length; i++){\n            combined[staticTraits.length + i] = dynamicTraits[i];\n        }\n\n        string memory metaData = Metadata.base64JsonDataURI(\n            json.objectOf(\n                Solarray.strings(\n                    json.property(\n                        \"name\",\n                        string.concat(\n                            \"Test SBT #\",\n                            LibString.toString(_tokenId)\n                        )\n                    ),\n                    json.property(\n                        \"description\",\n                        \"the Test SBT is a unique SBT that represents a user in the Origin Forge.\"\n                    ),\n                    json.property(\n                        \"image\",\n                        _generateSVG(_tokenId)\n                    ),\n                    json.rawProperty(\"attributes\", json.arrayOf(combined))\n                )\n            )\n        );\n\n        return metaData;\n    }\n\n    function getAttributes(uint _tokenId) internal view returns (string[] memory){\n        return Solarray.strings(\n            Metadata.attribute(\"seed\", s.sbt[_tokenId].seed, DisplayType.String),\n            Metadata.attribute(\"baseEgg\", s.sbt[_tokenId].baseEgg, DisplayType.Number)\n        );\n    }\n\n    function getDynamicAttributes(uint _tokenId) internal view returns (string[] memory){\n        string[] memory dynamicTraits = new string[](s.sbt[_tokenId].colorSet.length);\n        for(uint256 i = 0; i < s.sbt[_tokenId].colorSet.length; i++){\n            dynamicTraits[i] = Metadata.attribute(\"colorSet\", s.sbt[_tokenId].colorSet[i], DisplayType.String);\n        }\n        return dynamicTraits;\n    }\n\n    \n\n    function _generateSVG(uint _tokenId) public view returns (string memory) {\n        string memory svgString = string(abi.encodePacked(\n            '<svg width=\"500\" height=\"500\" viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\">',\n            '<defs>',\n            '<linearGradient id=\"borderGradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\">',\n            '<stop offset=\"0%\" style=\"stop-color:#ff0000;stop-opacity:1\">',\n            '<animate attributeName=\"stop-color\" values=\"#ff0000;#00ff00;#0000ff;#ff0000\" dur=\"4s\" repeatCount=\"indefinite\"/>',\n            '</stop>',\n            '<stop offset=\"100%\" style=\"stop-color:#0000ff;stop-opacity:1\">',\n            '<animate attributeName=\"stop-color\" values=\"#0000ff;#ff0000;#00ff00;#0000ff\" dur=\"4s\" repeatCount=\"indefinite\"/>',\n            '</stop>',\n            '</linearGradient>',\n            '</defs>',\n            '<rect width=\"100%\" height=\"100%\" fill=\"none\" stroke=\"url(#borderGradient)\" stroke-width=\"20\">',\n            '<animate attributeName=\"stroke-dasharray\" values=\"0,1500;1500,0;0,1500\" dur=\"10s\" repeatCount=\"indefinite\"/>',\n            '</rect>',\n            '<image x=\"50\" y=\"50\" width=\"400\" height=\"400\" href=\"',\n            _renderCharacter(_tokenId),\n            '\"/>',\n            // 속성 텍스트 추가\n            '<text x=\"50\" y=\"480\" font-family=\"Arial\" font-size=\"14\" fill=\"white\">',\n            'Seed: ', s.sbt[_tokenId].seed,\n            '</text>',\n            '<text x=\"200\" y=\"480\" font-family=\"Arial\" font-size=\"14\" fill=\"white\">',\n            'Base Egg: ', s.sbt[_tokenId].baseEgg,\n            '</text>',\n            _renderColorSetText(_tokenId),\n            '</svg>'\n        ));\n\n        return string(abi.encodePacked(\n            \"data:image/svg+xml;base64,\",\n            Base64.encode(bytes(svgString))\n        ));\n    }\n\n    function _renderColorSetText(uint _tokenId) internal view returns (string memory) {\n        string memory colorSetText = \"\";\n        for(uint i = 0; i < s.sbt[_tokenId].colorSet.length; i++) {\n            colorSetText = string(abi.encodePacked(\n                colorSetText,\n                '<text x=\"350\" y=\"',\n                LibString.toString(480 + (i * 20)),\n                '\" font-family=\"Arial\" font-size=\"14\" fill=\"white\">',\n                'Color ', LibString.toString(i+1), ': ',\n                s.sbt[_tokenId].colorSet[i],\n                '</text>'\n            ));\n        }\n        return colorSetText;\n    }\n\n    function _renderCharacter(uint _tokenId) internal view returns (string memory) {\n        return s.sbt[_tokenId].image;\n    }\n\n    function setSBT(uint _tokenId, string memory _image, string memory _seed, string memory _baseEgg, string[] memory _colorSet) external  {\n        s.sbt[_tokenId].image = _image;\n        s.sbt[_tokenId].seed = _seed;\n        s.sbt[_tokenId].baseEgg = _baseEgg;\n        s.sbt[_tokenId].colorSet = _colorSet;\n\n        \n    }\n\n    function mintSBT(address _to, string memory _userId) external {\n        IERC721 nft = IERC721(s.contractNames[\"nft\"]);\n        nft.safeMint(_to, s.users[_userId].userSBTId);\n    }\n\n    \n    \n\n}"
    },
    "contracts/shared/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/shared/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n//import \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n/* interface IERC721 is IERC165 { */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n\n    function burn(uint256 _tokenId) external;\n\n    function safeMintByMinter(address _to) external;\n\n    function _nextTokenId() external view returns (uint256);\n\n    function safeMint(address to, uint tokenId) external returns (uint);\n\n    function diamondMint(address to, uint256 tokenId) external;\n\n    function _update_metadata_uri(uint _tokenId) external;\n\n    function increaseTokenId() external;\n}\n"
    },
    "contracts/shared/libraries/json.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibString} from \"solady/src/utils/LibString.sol\";\n\n/**\n * @title JSON\n * @author emo.eth\n * @notice TODO: overrides for common types that automatically stringify\n */\nlibrary json {\n    string private constant NULL = \"\";\n\n    using LibString for string;\n\n    /**\n     * @notice enclose a string in {braces}\n     *         Note: does not escape quotes in value\n     * @param  value string to enclose in braces\n     * @return string of {value}\n     */\n    function object(string memory value) internal pure returns (string memory) {\n        return string.concat(\"{\", value, \"}\");\n    }\n\n    /**\n     * @notice enclose a string in [brackets]\n     *         Note: does not escape quotes in value\n     * @param value string to enclose in brackets\n     * @return string of [value]\n     */\n    function array(string memory value) internal pure returns (string memory) {\n        return string.concat(\"[\", value, \"]\");\n    }\n\n    /**\n     * @notice enclose name and value with quotes, and place a colon \"between\":\"them\".\n     *         Note: escapes quotes in name and value\n     * @param name name of property\n     * @param value value of property\n     * @return string of \"name\":\"value\"\n     */\n    function property(\n        string memory name,\n        string memory value\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                '\"',\n                name.escapeJSON(),\n                '\":\"',\n                value.escapeJSON(),\n                '\"'\n            );\n    }\n\n    /**\n     * @notice enclose name with quotes, but not rawValue, and place a colon \"between\":them\n     *         Note: escapes quotes in name, but not value (which may itself be a JSON object, array, etc)\n     * @param name name of property\n     * @param rawValue raw value of property, which will not be enclosed in quotes\n     * @return string of \"name\":value\n     */\n    function rawProperty(\n        string memory name,\n        string memory rawValue\n    ) internal pure returns (string memory) {\n        return string.concat('\"', name.escapeJSON(), '\":', rawValue);\n    }\n\n    /**\n     * @notice comma-join an array of properties and {\"enclose\":\"them\",\"in\":\"braces\"}\n     *         Note: does not escape quotes in properties, as it assumes they are already escaped\n     * @param properties array of '\"name\":\"value\"' properties to join\n     * @return string of {\"name\":\"value\",\"name\":\"value\",...}\n     */\n    function objectOf(\n        string[] memory properties\n    ) internal pure returns (string memory) {\n        return object(_commaJoin(properties));\n    }\n\n    /**\n     * @notice comma-join an array of values and enclose them [in,brackets]\n     *         Note: does not escape quotes in values, as it assumes they are already escaped\n     * @param values array of values to join\n     * @return string of [value,value,...]\n     */\n    function arrayOf(\n        string[] memory values\n    ) internal pure returns (string memory) {\n        return array(_commaJoin(values));\n    }\n\n    /**\n     * @notice comma-join two arrays of values and [enclose,them,in,brackets]\n     *         Note: does not escape quotes in values, as it assumes they are already escaped\n     * @param values1 first array of values to join\n     * @param values2 second array of values to join\n     * @return string of [values1_0,values1_1,values2_0,values2_1...]\n     */\n    function arrayOf(\n        string[] memory values1,\n        string[] memory values2\n    ) internal pure returns (string memory) {\n        if (values1.length == 0) {\n            return arrayOf(values2);\n        } else if (values2.length == 0) {\n            return arrayOf(values1);\n        }\n        return\n            array(string.concat(_commaJoin(values1), \",\", _commaJoin(values2)));\n    }\n\n    /**\n     * @notice enclose a string in double \"quotes\", escaping any existing quotes\n     * @param str string to enclose in quotes\n     * @return string of \"value\"\n     */\n    function quote(string memory str) internal pure returns (string memory) {\n        return string.concat('\"', str.escapeJSON(), '\"');\n    }\n\n    /**\n     * @notice enclose each string in an array in double \"quotes\", escaping any existing quotes\n     * @param strs array of strings, each to escape and enclose in quotes\n     */\n    function quote(\n        string[] memory strs\n    ) internal pure returns (string[] memory) {\n        string[] memory result = new string[](strs.length);\n        for (uint256 i = 0; i < strs.length; ) {\n            result[i] = quote(strs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @notice comma-join an array of strings\n     * @param values array of strings to join\n     * @return string of value,value,...\n     */\n    function _commaJoin(\n        string[] memory values\n    ) internal pure returns (string memory) {\n        return _join(values, \",\");\n    }\n\n    /**\n     * @notice join two strings with a comma\n     * @param value1 first string\n     * @param value2 second string\n     * @return string of value1,value2\n     */\n    function _commaJoin(\n        string memory value1,\n        string memory value2\n    ) internal pure returns (string memory) {\n        return string.concat(value1, \",\", value2);\n    }\n\n    /**\n     * @notice join an array of strings with a specified separator\n     * @param values array of strings to join\n     * @param separator separator to join with\n     * @return string of value<separator>value<separator>...\n     */\n    function _join(\n        string[] memory values,\n        string memory separator\n    ) internal pure returns (string memory) {\n        if (values.length == 0) {\n            return NULL;\n        }\n        string memory result = values[0];\n        for (uint256 i = 1; i < values.length; ++i) {\n            result = string.concat(result, separator, values[i]);\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibUintQueueLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary UintQueueLibrary {\n    struct UintQueue {\n        uint256[] data;\n    }\n\n    // Add an element to the front of the queue\n    function addFront(UintQueue storage queue, uint256 element) internal {\n        queue.data.push(element); // Add element at the end\n        uint256 len = queue.data.length;\n        for (uint256 i = len - 1; i > 0; i--) {\n            queue.data[i] = queue.data[i - 1];\n        }\n        queue.data[0] = element; // Move element to the front\n    }\n\n    // Add an element to the back of the queue\n    function addBack(UintQueue storage queue, uint256 element) internal {\n        queue.data.push(element);\n    }\n\n    // Add an element to the middle of the queue at the specified index\n    function addMiddle(\n        UintQueue storage queue,\n        uint256 element,\n        uint256 index\n    ) internal {\n        require(index <= queue.data.length, \"Index out of bounds\");\n\n        queue.data.push(element); // Add element at the end\n        for (uint256 i = queue.data.length - 1; i > index; i--) {\n            queue.data[i] = queue.data[i - 1];\n        }\n        queue.data[index] = element; // Move element to the middle\n    }\n\n    // Remove an element from the front of the queue\n    function removeFront(UintQueue storage queue) internal returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n\n        uint256 element = queue.data[0];\n        for (uint256 i = 0; i < queue.data.length - 1; i++) {\n            queue.data[i] = queue.data[i + 1];\n        }\n        queue.data.pop();\n        return element;\n    }\n\n    // Remove an element from the back of the queue\n    function removeBack(UintQueue storage queue) internal returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n\n        uint256 element = queue.data[queue.data.length - 1];\n        queue.data.pop();\n        return element;\n    }\n\n    // Remove an element from the middle of the queue at the specified index\n    function removeMiddle(\n        UintQueue storage queue,\n        uint256 index\n    ) internal returns (uint256) {\n        require(index < queue.data.length, \"Index out of bounds\");\n\n        uint256 element = queue.data[index];\n        for (uint256 i = index; i < queue.data.length - 1; i++) {\n            queue.data[i] = queue.data[i + 1];\n        }\n        queue.data.pop();\n        return element;\n    }\n\n    // Get the element at the front of the queue\n    function front(UintQueue storage queue) internal view returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n        return queue.data[0];\n    }\n\n    // Get the element at the back of the queue\n    function back(UintQueue storage queue) internal view returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n        return queue.data[queue.data.length - 1];\n    }\n\n    // Check if the queue is empty\n    function isEmpty(UintQueue storage queue) internal view returns (bool) {\n        return queue.data.length == 0;\n    }\n\n    // Get the number of elements in the queue\n    function length(UintQueue storage queue) internal view returns (uint256) {\n        return queue.data.length;\n    }\n\n    // Get the element at a specific index in the queue\n    function get(\n        UintQueue storage queue,\n        uint256 index\n    ) internal view returns (uint256) {\n        require(index < queue.data.length, \"Index out of bounds\");\n        return queue.data[index];\n    }\n\n    // Get the elements from the specified range of indices in the queue\n    function getRange(\n        UintQueue storage queue,\n        uint256 fromIndex,\n        uint256 toIndex\n    ) internal view returns (uint256[] memory) {\n        require(fromIndex <= toIndex, \"Invalid index range\");\n        require(toIndex < queue.data.length, \"Index out of bounds\");\n\n        uint256 length = toIndex - fromIndex + 1;\n        uint256[] memory range = new uint256[](length);\n        for (uint256 i = fromIndex; i <= toIndex; i++) {\n            range[i - fromIndex] = queue.data[i];\n        }\n        return range;\n    }\n\n    // Get the elements from the specified range of indices in the queue in reverse order\n    function getRangeReverse(\n        UintQueue storage queue,\n        uint256 fromIndex,\n        uint256 toIndex\n    ) internal view returns (uint256[] memory) {\n        require(fromIndex <= toIndex, \"Invalid index range\");\n        require(toIndex < queue.data.length, \"Index out of bounds\");\n\n        uint256 length = toIndex - fromIndex + 1;\n        uint256[] memory range = new uint256[](length);\n        for (uint256 i = 0; i < length; i++) {\n            range[i] = queue.data[toIndex - i];\n        }\n        return range;\n    }\n\n    function findIndex(\n        UintQueue storage queue,\n        uint256 element\n    ) internal view returns (int256) {\n        for (uint256 i = 0; i < queue.data.length; i++) {\n            if (queue.data[i] == element) {\n                return int256(i);\n            }\n        }\n        return -1; // Return -1 if the element is not found\n    }\n\n    function removeElement(\n        UintQueue storage queue,\n        uint256 element\n    ) internal returns (bool) {\n        int256 index = findIndex(queue, element);\n        if (index == -1) {\n            return false; // Element not found\n        }\n\n        for (uint256 i = uint256(index); i < queue.data.length - 1; i++) {\n            queue.data[i] = queue.data[i + 1];\n        }\n        queue.data.pop();\n        return true;\n    }\n}"
    },
    "contracts/shared/libraries/Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {json} from \"./json.sol\";\nimport {LibString} from \"solady/src/utils/LibString.sol\";\nimport {Solarray} from \"./Solarray.sol\";\nimport {Base64} from \"solady/src/utils/Base64.sol\";\n\nenum DisplayType {\n    String,\n    Number,\n    Date,\n    BoostPercent,\n    BoostNumber,\n    Hidden\n}\n\nlibrary Metadata {\n    string private constant NULL = \"\";\n\n    using LibString for string;\n\n    function attribute(\n        string memory traitType,\n        string memory value\n    ) internal pure returns (string memory) {\n        return\n            json.objectOf(\n                Solarray.strings(\n                    json.property(\"trait_type\", traitType),\n                    json.property(\"value\", value)\n                )\n            );\n    }\n\n    function attribute(\n        string memory traitType,\n        string memory value,\n        DisplayType displayType\n    ) internal pure returns (string memory) {\n        return\n            json.objectOf(\n                Solarray.strings(\n                    json.property(\"trait_type\", traitType),\n                    json.property(\"value\", value),\n                    json.property(\"display_type\", toString(displayType))\n                )\n            );\n    }\n\n    function toString(\n        DisplayType displayType\n    ) internal pure returns (string memory) {\n        if (displayType == DisplayType.String) {\n            return \"string\";\n        } else if (displayType == DisplayType.Number) {\n            return \"number\";\n        } else if (displayType == DisplayType.Date) {\n            return \"date\";\n        } else if (displayType == DisplayType.BoostNumber) {\n            return \"boost_number\";\n        } else if (displayType == DisplayType.BoostPercent) {\n            return \"boost_percent\";\n        } else {\n            return \"hidden\";\n        }\n    }\n\n    function dataURI(\n        string memory dataType,\n        string memory encoding,\n        string memory content\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"data:\",\n                dataType,\n                \";\",\n                bytes(encoding).length > 0\n                    ? string.concat(encoding, \",\")\n                    : NULL,\n                content\n            );\n    }\n\n    function dataURI(\n        string memory dataType,\n        string memory content\n    ) internal pure returns (string memory) {\n        return dataURI(dataType, NULL, content);\n    }\n\n    function jsonDataURI(\n        string memory content,\n        string memory encoding\n    ) internal pure returns (string memory) {\n        return dataURI(\"application/json\", encoding, content);\n    }\n\n    function jsonDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return jsonDataURI(content, NULL);\n    }\n\n    function base64JsonDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return jsonDataURI(Base64.encode(bytes(content)), \"base64\");\n    }\n\n    function svgDataURI(\n        string memory content,\n        string memory encoding,\n        bool escape\n    ) internal pure returns (string memory) {\n        string memory uri = dataURI(\"image/svg+xml\", encoding, content);\n\n        if (escape) {\n            return uri.escapeJSON();\n        } else {\n            return uri;\n        }\n    }\n\n    function svgDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return svgDataURI(content, \"utf8\", true);\n    }\n\n    function base64SvgDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return svgDataURI(Base64.encode(bytes(content)), \"base64\", false);\n    }\n}\n"
    },
    "contracts/shared/libraries/Solarray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary Solarray {\n    \n    function uint8s(uint8 a) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d,uint8 e) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d,uint8 e,uint8 f) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d,uint8 e,uint8 f,uint8 g) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d,uint16 e) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d,uint16 e,uint16 f) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d,uint16 e,uint16 f,uint16 g) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d,uint32 e) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d,uint32 e,uint32 f) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d,uint32 e,uint32 f,uint32 g) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n    \n    function uint40s(uint40 a) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d,uint40 e) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d,uint40 e,uint40 f) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d,uint40 e,uint40 f,uint40 g) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n    function uint64s(uint64 a) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d,uint64 e) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d,uint64 e,uint64 f) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d,uint64 e,uint64 f,uint64 g) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d,uint128 e) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d,uint128 e,uint128 f) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d,uint128 e,uint128 f,uint128 g) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d,uint256 e) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d,uint256 e,uint256 f) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d,uint256 e,uint256 f,uint256 g) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int8s(int8 a) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d,int8 e) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d,int8 e,int8 f) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d,int8 e,int8 f,int8 g) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int16s(int16 a) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d,int16 e) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d,int16 e,int16 f) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d,int16 e,int16 f,int16 g) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int32s(int32 a) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d,int32 e) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d,int32 e,int32 f) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d,int32 e,int32 f,int32 g) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int64s(int64 a) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d,int64 e) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d,int64 e,int64 f) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d,int64 e,int64 f,int64 g) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int128s(int128 a) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d,int128 e) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d,int128 e,int128 f) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d,int128 e,int128 f,int128 g) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int256s(int256 a) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d,int256 e) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d,int256 e,int256 f) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d,int256 e,int256 f,int256 g) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d,bytes1 e) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d,bytes1 e,bytes1 f) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d,bytes1 e,bytes1 f,bytes1 g) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d,bytes8 e) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d,bytes8 e,bytes8 f) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d,bytes8 e,bytes8 f,bytes8 g) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d,bytes16 e) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d,bytes16 e,bytes16 f) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d,bytes16 e,bytes16 f,bytes16 g) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d,bytes20 e) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d,bytes20 e,bytes20 f) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d,bytes20 e,bytes20 f,bytes20 g) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d,bytes32 e) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d,bytes32 e,bytes32 f) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d,bytes32 e,bytes32 f,bytes32 g) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d,bytes memory e) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d,bytes memory e,bytes memory f) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d,bytes memory e,bytes memory f,bytes memory g) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function addresses(address a) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function addresses(address a,address b) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d,address e) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d,address e,address f) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d,address e,address f,address g) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bools(bool a) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d,bool e) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d,bool e,bool f) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d,bool e,bool f,bool g) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function strings(string memory a) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d,string memory e) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d,string memory e,string memory f) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d,string memory e,string memory f,string memory g) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n}"
    },
    "contracts/shared/libraries/svg.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {LibString} from \"solady/src/utils/LibString.sol\";\n\nlibrary svg {\n    using LibString for uint256;\n\n    // used to simulate empty strings\n    string internal constant NULL = \"\";\n\n    function top(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return svg_(true, props, children);\n    }\n\n    function svg_(\n        bool includeXmlns,\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        if (includeXmlns) {\n            return\n                el(\n                    \"svg\",\n                    string.concat('xmlns=\"http://www.w3.org/2000/svg\" ', props),\n                    children\n                );\n        } else {\n            return el(\"svg\", props, children);\n        }\n    }\n\n    function g(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"g\", props, children);\n    }\n\n    function path(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"path\", props, children);\n    }\n\n    function text(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"text\", props, children);\n    }\n\n    function line(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"line\", props, children);\n    }\n\n    function circle(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"circle\", props, children);\n    }\n\n    function circle(string memory props) internal pure returns (string memory) {\n        return el(\"circle\", props);\n    }\n\n    function rect(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"rect\", props, children);\n    }\n\n    function rect(string memory props) internal pure returns (string memory) {\n        return el(\"rect\", props);\n    }\n\n    function filter(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"filter\", props, children);\n    }\n\n    function cdata(\n        string memory content\n    ) internal pure returns (string memory) {\n        return string.concat(\"<![CDATA[\", content, \"]]>\");\n    }\n\n    /* GRADIENTS */\n    function radialGradient(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"radialGradient\", props, children);\n    }\n\n    function linearGradient(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"linearGradient\", props, children);\n    }\n\n    function gradientStop(\n        uint256 offset,\n        string memory stopColor,\n        string memory props\n    ) internal pure returns (string memory) {\n        return\n            el(\n                \"stop\",\n                string.concat(\n                    prop(\"stop-color\", stopColor),\n                    prop(\"offset\", string.concat(offset.toString(), \"%\")),\n                    props\n                )\n            );\n    }\n\n    function animateTransform(\n        string memory props\n    ) internal pure returns (string memory) {\n        return el(\"animateTransform\", props);\n    }\n\n    function image(\n        string memory href,\n        string memory props\n    ) internal pure returns (string memory) {\n        return el(\"image\", string.concat(prop(\"href\", href), props));\n    }\n\n    /* COMMON */\n    // A generic element, can be used to construct any SVG (or HTML) element\n    function el(\n        string memory tag,\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\"<\", tag, \" \", props, \">\", children, \"</\", tag, \">\");\n    }\n\n    // A generic element, can be used to construct any SVG (or HTML) element without children\n    function el(\n        string memory tag,\n        string memory props\n    ) internal pure returns (string memory) {\n        return string.concat(\"<\", tag, \" \", props, \"/>\");\n    }\n\n    // an SVG attribute\n    function prop(\n        string memory key,\n        string memory val\n    ) internal pure returns (string memory) {\n        return string.concat(key, \"=\", '\"', val, '\" ');\n    }\n\n    // formats a CSS variable line. includes a semicolon for formatting.\n    function setCssVar(\n        string memory key,\n        string memory val\n    ) internal pure returns (string memory) {\n        return string.concat(\"--\", key, \":\", val, \";\");\n    }\n\n    // formats getting a css variable\n    function getCssVar(\n        string memory key\n    ) internal pure returns (string memory) {\n        return string.concat(\"var(--\", key, \")\");\n    }\n\n    // formats getting a def URL\n    function getDefURL(string memory id) internal pure returns (string memory) {\n        return string.concat(\"url(#\", id, \")\");\n    }\n\n    // formats generic rgba color in css\n    function rgba(\n        uint256 r,\n        uint256 _g,\n        uint256 b,\n        uint256 a\n    ) internal pure returns (string memory) {\n        string memory formattedA = a < 100\n            ? string.concat(\"0.\", a.toString())\n            : \"1\";\n        return\n            string.concat(\n                \"rgba(\",\n                r.toString(),\n                \",\",\n                _g.toString(),\n                \",\",\n                b.toString(),\n                \",\",\n                formattedA,\n                \")\"\n            );\n    }\n}\n"
    },
    "contracts/shared/storage/facets/AppStorageFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../../libraries/LibDiamond.sol\";\n\nimport \"../structs/AppStorage.sol\";\n\ncontract AppStorageFacet {\n    AppStorage internal s;\n\n    function appStorage() internal pure returns (AppStorage storage ds){\n      assembly {\n        ds.slot := 0\n      }\n    }\n\n}\n"
    },
    "contracts/shared/storage/structs/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"../../libraries/LibEnumerableSet.sol\";\nimport {UintQueueLibrary} from \"../../libraries/LibUintQueueLibrary.sol\";\n\n\nusing EnumerableSet for EnumerableSet.UintSet;\nusing UintQueueLibrary for UintQueueLibrary.UintQueue;\n\n\nstruct User {\n    string userId;\n    string userNickName;\n    // 유저가 등록한 지갑\n    address userWallet;\n    // 등록한 지갑과 연결되어있는 대리 지갑\n    address delegateAccount;\n    // 유저의 SBT ID\n    uint256 userSBTId;\n    // User의 OriginValue\n    uint256 originValue;\n}\n\nstruct DelegateAccount {\n    string userId;\n    address connectedWallet;\n    // bool isConnected;\n}\n\nstruct SBT {\n    uint256 tokenId;\n    string image;\n    string seed;\n    string baseEgg;\n    string[] colorSet;\n}\n\nstruct AppStorage {\n    mapping(string => address) contractNames;\n    mapping(string => User) users;\n    mapping(uint256 => SBT) sbt;\n    mapping(string => bool) isUseNickName;\n}\n"
    },
    "contracts/shared/utils/modifiersFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {AppStorage} from \"../storage/facets/AppStorageFacet.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract modifiersFacet {\n    AppStorage internal s;\n\n    modifier onlyAdmin() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n\n    modifier onlyEOA(address _address) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        \n        require(size == 0, \"ModifiersFacet: not EOA\");\n        _;\n    }\n\n\n    \n}\n"
    },
    "solady/src/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"
    },
    "solady/src/utils/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for byte related operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\nlibrary LibBytes {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so it’s mad tight.\n    struct BytesStorage {\n        bytes32 _spacer;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the bytes.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BYTE STORAGE OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\n    function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty bytes \"\".\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(and(packed, 0xff), 0xff)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      BYTES OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset.\n    function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of bytess based on the `delimiter` inside of the `subject` bytes.\n    function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated bytes of `a` and `b`.\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(bytes memory a) internal pure {\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(load(a, offset)))`.\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(loadCalldata(a, offset)))`.\n    function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }\n}\n"
    },
    "solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibBytes} from \"./LibBytes.sol\";\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Goated string storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native string storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so it’s mad tight.\n    struct StringStorage {\n        bytes32 _spacer;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /// @dev The input string must be a 7-bit ASCII.\n    error StringNot7BitASCII();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\n\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\n\n    /// @dev Lookup for '0123456789'.\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\n\n    /// @dev Lookup for '01234567'.\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\n\n    /// @dev Lookup for '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\n\n    /// @dev Lookup for ' \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                 STRING STORAGE OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function set(StringStorage storage $, string memory s) internal {\n        LibBytes.set(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function setCalldata(StringStorage storage $, string calldata s) internal {\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to the empty string.\n    function clear(StringStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty string \"\".\n    function isEmpty(StringStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(StringStorage storage $) internal view returns (uint256) {\n        return LibBytes.length(bytesStorage($));\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(StringStorage storage $) internal view returns (string memory) {\n        return string(LibBytes.get(bytesStorage($)));\n    }\n\n    /// @dev Helper to cast `$` to a `BytesStorage`.\n    function bytesStorage(StringStorage storage $)\n        internal\n        pure\n        returns (LibBytes.BytesStorage storage casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.slot := $.slot\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the '-' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2 + 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, byteCount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is not prefixed with \"0x\" and is encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(byteCount, byteCount))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string,\n    /// AND all characters are in the `allowed` lookup.\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\n    /// To save runtime gas, you can cache the result in an immutable variable.\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.contains(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\n        return string(LibBytes.repeat(bytes(subject), times));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.slice(bytes(subject), start, end));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory) {\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(LibBytes.concat(bytes(a), bytes(b)));\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // \"\\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // \"\\\\u00XX\".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // \"\\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Encodes `s` so that it can be safely used in a URI,\n    /// just like `encodeURIComponent` in JavaScript.\n    /// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    /// See: https://datatracker.ietf.org/doc/html/rfc2396\n    /// See: https://datatracker.ietf.org/doc/html/rfc3986\n    function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store \"0123456789ABCDEF\" in scratch space.\n            // Uppercased to be consistent with JavaScript's implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // '%'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),\n                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLen, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}